<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jeu de la Vie - Vitesse en Temps Réel</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; margin: 20px; }
    #gameCanvas { border: 1px solid #000; touch-action: none; }
    .controls { margin-bottom: 10px; }
  </style>
</head>
<body>
  <h1>Jeu de la Vie - Vitesse en Temps Réel</h1>
  <div class="controls">
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
    <button id="resetBtn">Reset</button>
    Vitesse : <input type="range" id="speedSlider" min="50" max="1000" step="50" value="500">
    Taille de la grille : <input type="number" id="gridSizeInput" min="10" max="100" value="50">
    <button id="resizeBtn">Redimensionner</button>
    <br><br>
    Configuration de départ : 
    <select id="patternSelect">
      <option value="empty">Vide</option>
      <option value="glider">Glider</option>
      <option value="random">Aléatoire</option>
    </select>
    <button id="applyPatternBtn">Appliquer</button>
  </div>
  <canvas id="gameCanvas" width="600" height="600"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    let grid = [];
    let gridSize = parseInt(document.getElementById("gridSizeInput").value);
    let cellSize = canvas.width / gridSize;
    let simulationTimeout = null;
    let running = false;

    // Calcule le délai à appliquer en fonction de la valeur du slider
    function getIntervalDelay() {
      const slider = document.getElementById("speedSlider");
      const minSpeed = parseInt(slider.min);
      const maxSpeed = parseInt(slider.max);
      const sliderValue = parseInt(slider.value);
      // Valeur basse = simulation lente, valeur haute = simulation rapide
      return maxSpeed + minSpeed - sliderValue;
    }

    // Initialise la grille avec des cellules mortes (0)
    function initGrid() {
      grid = [];
      for (let i = 0; i < gridSize; i++) {
        grid[i] = [];
        for (let j = 0; j < gridSize; j++) {
          grid[i][j] = 0;
        }
      }
    }

    // Affiche la grille sur le canvas
    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          ctx.fillStyle = grid[i][j] === 1 ? "#000" : "#fff";
          ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
          ctx.strokeStyle = "#ccc";
          ctx.strokeRect(j * cellSize, i * cellSize, cellSize, cellSize);
        }
      }
    }

    // Calcule la prochaine génération en tenant compte du repliement (effet torique)
    function nextGeneration() {
      const newGrid = [];
      for (let i = 0; i < gridSize; i++) {
        newGrid[i] = [];
        for (let j = 0; j < gridSize; j++) {
          let aliveNeighbors = 0;
          for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
              if (x === 0 && y === 0) continue;
              const ni = (i + x + gridSize) % gridSize;
              const nj = (j + y + gridSize) % gridSize;
              aliveNeighbors += grid[ni][nj];
            }
          }
          newGrid[i][j] = grid[i][j] === 1 
            ? ((aliveNeighbors === 2 || aliveNeighbors === 3) ? 1 : 0)
            : (aliveNeighbors === 3 ? 1 : 0);
        }
      }
      grid = newGrid;
      drawGrid();
    }

    // Boucle récursive qui lance chaque génération avec le délai courant
    function simulationStep() {
      if (!running) return;
      nextGeneration();
      simulationTimeout = setTimeout(simulationStep, getIntervalDelay());
    }

    // Démarre la simulation
    function startSimulation() {
      if (!running) {
        running = true;
        simulationStep();
      }
    }

    // Arrête la simulation
    function stopSimulation() {
      running = false;
      clearTimeout(simulationTimeout);
      simulationTimeout = null;
    }

    // Met à jour la vitesse en temps réel
    function updateSpeed() {
      if (running) {
        // Annule le délai en cours et en programme un nouveau
        clearTimeout(simulationTimeout);
        simulationTimeout = setTimeout(simulationStep, getIntervalDelay());
      }
    }

    // Réinitialise la grille (et arrête la simulation)
    function resetGrid() {
      stopSimulation();
      initGrid();
      drawGrid();
    }

    // Redimensionne la grille selon la taille saisie
    function resizeGrid() {
      stopSimulation();
      gridSize = parseInt(document.getElementById("gridSizeInput").value);
      cellSize = canvas.width / gridSize;
      initGrid();
      drawGrid();
    }

    // Applique une configuration de départ particulière
    function applyPattern() {
      resetGrid();
      const pattern = document.getElementById("patternSelect").value;
      const midRow = Math.floor(gridSize / 2);
      const midCol = Math.floor(gridSize / 2);
      if (pattern === "glider") {
        grid[midRow][midCol+1] = 1;
        grid[midRow+1][midCol+2] = 1;
        grid[midRow+2][midCol] = 1;
        grid[midRow+2][midCol+1] = 1;
        grid[midRow+2][midCol+2] = 1;
      } else if (pattern === "random") {
        for (let i = 0; i < gridSize; i++){
          for (let j = 0; j < gridSize; j++){
            grid[i][j] = Math.random() > 0.8 ? 1 : 0;
          }
        }
      }
      drawGrid();
    }

    // Permet d'ajouter ou d'effacer une cellule par clic ou touch lorsque la simulation est arrêtée
    function toggleCell(e) {
      if (running) return;
      const rect = canvas.getBoundingClientRect();
      const clientX = e.clientX || (e.touches && e.touches[0].clientX);
      const clientY = e.clientY || (e.touches && e.touches[0].clientY);
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      const j = Math.floor(x / cellSize);
      const i = Math.floor(y / cellSize);
      if (i >= 0 && i < gridSize && j >= 0 && j < gridSize) {
        grid[i][j] = grid[i][j] ? 0 : 1;
        drawGrid();
      }
    }

    // Écouteurs d'événements
    document.getElementById("startBtn").addEventListener("click", startSimulation);
    document.getElementById("stopBtn").addEventListener("click", stopSimulation);
    document.getElementById("resetBtn").addEventListener("click", resetGrid);
    document.getElementById("resizeBtn").addEventListener("click", resizeGrid);
    document.getElementById("applyPatternBtn").addEventListener("click", applyPattern);
    canvas.addEventListener("click", toggleCell);
    canvas.addEventListener("touchstart", function(e) {
      e.preventDefault();
      toggleCell(e);
    });
    // L'événement "input" sur le slider met à jour la vitesse en temps réel
    document.getElementById("speedSlider").addEventListener("input", updateSpeed);

    // Initialisation
    initGrid();
    drawGrid();
  </script>
</body>
</html>
